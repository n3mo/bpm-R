#! /usr/bin/env Rscript

currVer = "v0.1.2"

## Parse command line arguments if present
args = commandArgs(TRUE)

if (is.na(args[1])) {
    root = "~/media/Television"
} else {
    root = args[1]
}

getFileData <- function(root) {
    ## Recursively search root directory for video files and return a
    ## data frame containing file paths and file names (without path
    ## or file extension info)

    ## Regexp that matches video files
    videoRegex = ".+\\.flv$|mov$|mp4$|wmv$|mkv$|mov$|avi$|mpg$|swf$"

    ## Read in the files from the specified root directory
    filePath = list.files(root, videoRegex,
        recursive=TRUE, full.names=T)

    ## File names (with path or extension)
    fileName = sub("\\.[[:alnum:]]{3}", "", basename(filePath))

    ## By default, files are returned in the order in which the
    ## directory was traversed. This means that the original directory
    ## name rather than the file name determines how it is
    ## sorted. Here, we instead sort alphabetically by file *name*
    ## instead and use this new permutation when creating our data
    ## frame below
    idx = order(fileName)

    ## Create a data frame and return
    return(data.frame(filePath = filePath[idx], fileName = fileName[idx]))

}

trashFiles <- function(flist) {
    ## Deletes (moves to trash) files contained in flist. In addition,
    ## if trashSimilar == TRUE, files with the same name but different
    ## extensions are deleted as well! This takes care of subtitle
    ## files, etc. that would otherwise accumulate on the
    ## system. However, if you have two copies of the same video in
    ## different formats (e.g., .avi and .mkv), they will both be
    ## deleted by this!

    ## Regular expression that matches video files ending with
    ## supported file extensions
    videoRegex = ".+\\.flv$|mov$|mp4$|wmv$|mkv$|mov$|avi$|mpg$|swf$"

    ## Location of trash directory on the current system
    ## TODO: make this not hardwired
    trashPath = "~/.local/share/Trash/files"
    
    for (currFile in flist) {

        ## Directory for current file
        fileDir = dirname(currFile)
        ## File name of current file
        fileName = sub("\\.[[:alnum:]]{3}", "", basename(currFile))
        
        ## This is annoying, but if the file has () in it, they must
        ## be escaped to avoid the grouping behavior of parentheses in
        ## regexps
        quotedFileName = gsub("\\(", "\\\\(", fileName)
        ## Same goes for .
        quotedFileName = gsub("\\.", "\\\\.", quotedFileName)

        ## We construct a regular expression that matches files with
        ## the same file name but different extensions
        fileRegex = paste("^", quotedFileName, "\\.[[:alnum:]]{3}$", sep="")

        ## File all files in the current directory with the same name
        ## (but different extension)
        myFiles = list.files(fileDir, fileRegex, full.names=TRUE) 

        ## Don't include the current file for deletion, which would be
        ## found by the above regexp
        myFiles = setdiff(myFiles, file.path(fileDir,
            basename(currFile))) 

        ## Don't delete video files with the same name (if the user
        ## has multiple copies of the same video in different formats,
        ## we don't want to delete those copies)
        idx = grep(videoRegex, myFiles)
        
        ## This removes videos files from our vector (so that they do
        ## NOT get deleted)
        if (length(idx) > 0) {myFiles = myFiles[-idx]}

        ## Add the original file to the deletion list
        myFiles = c(myFiles, currFile)

        ## We're finally ready for deleting files associated with
        ## currFile as well as currFile itself. Now we delete them
        ## (actually, we move them to the trash)
        file.rename(myFiles, file.path(trashPath, basename(myFiles)))
    }
}

splashLogo <- function() {
cat("\t\t\t\t\t    __                  \n", 
    "\t\t\t\t\t   / /_  ____  ____ ___ \n", 
    "\t\t\t\t\t  / __ \\/ __ \\/ __ `__ \\\n", 
    "\t\t\t\t\t / /_/ / /_/ / / / / / /\n", 
    "\t\t\t\t\t/_.___/ .___/_/ /_/ /_/ \n", 
    sprintf("\t\t\t\t\t     /_/           %s\n", currVer),
    sep = "")
}

videoDuration <- function(filePath) {
    ## Calls mplayer to determine the duration of the video file at
    ## filePath and returns the duration in seconds

    ## Grab the video's meta-data using mplayer
    tmp = system(
        paste("mplayer -vo null -ao null -identify -frames 0",
              shQuote(filePath[1]), sep=" "),
        intern = T, ignore.stderr = T)

    ## Find the duration of the video in the meta-data
    x = grep("ID_LENGTH.*", tmp, value=T)
    ## Extract the number of seconds
    m = regexpr("[[:digit:]]+\\.*[[:digit:]]*$", x)
    tmp = regmatches(x, m)
    ## Convert to minutes and return
    return(round(as.numeric(tmp) / 60, 1))
}

displayFiles <- function(flist) {

    ## Displays a list of files in pretty fashion
    system("clear")
    splashLogo()
    cat("-------------------------------------",
        "-----------------------------\n",
        sprintf("%s\t%s\n", "Item", "Title"),
        "-------------------------------------",
        "-----------------------------\n", sep="")
    for (i in 1:length(flist$fileName)) {
        cat(sprintf("%02d\t%s\n", i, flist$fileName[i]))
    }
}

handleResp <- function(d, resp, startIdx, maxFiles, maxItem) {
    ## Manages user input and calls the appropriate function

    ## Try to handle the user's unpredictable input
    tryCatch(
        {
            ## Initial letter/number of resp determines behavior
            initialResp = substr(resp, 1, 1)

            ## If the resp is just a number, play the corresponding video
            if (length(grep("[[:digit:]]", initialResp)) == 1) {
                ## Play corresponding video and wait for it to return
                respAsNum = as.numeric(resp)
                vidChoice = respAsNum + (startIdx - 1)

                ## Only allow reasonable item numbers
                if (respAsNum <1 | respAsNum > maxItem) {
                    ## Do nothing... the user has asked for an illegal
                    ## item number
                    return(startIdx)
                } 

                cat(sprintf("Playing %s...", d$fileName[vidChoice]))
                system(paste("mplayer -really-quiet",
                             shQuote(d$filePath[vidChoice]),
                             sep=" "),
                       wait=T, ignore.stdout = TRUE,
                       ignore.stderr = TRUE) 

                ## Return the original startIdx (which means the browser will
                ## simply return to its previous state after the video has
                ## finished playing)
                return(startIdx)
            }

            ## The user could have asked to see the next page of videos
            if (tolower(initialResp) == "n") {
                ## Return index of the next page of results
                return(startIdx + maxFiles)
            } else if (tolower(initialResp) == "p") {
                ## The user has asked to see the previous page of videos
                return(startIdx - maxFiles)
            } else if (tolower(initialResp) == "q") {
                ## The user wants to quit
                return(0)
            } else if (tolower(initialResp) == "t") {
                ## Return to the top page of results
                return(1)
            } else {
                ## The response is illegal. If it didn't cause an
                ## error, we just return the current state of things
                return(startIdx)
            }
            
        },
        error = function(e) {
            cat('Unknown Command!\n')
        })
    return(startIdx)
}

fileBrowser <- function(d) {
    ## Controls how many files are displayed at a time, and acts as a
    ## dispatcher for different functionality, including the playback
    ## and deletion of videos.
    browsep = TRUE
    ## The starting video index in the browser window. This is used to
    ## display a subset of a very long list of videos
    startIdx = 1
    ## How many files to display onscreen at once
    maxFiles = 15
    numVideos = dim(d)[1]

    ## Given the number of files per page, what is the total pages of
    ## results possible?
    maxPage = ceiling(numVideos / maxFiles)
    
    while (browsep) {
        ## Double check that our indexes are not out of range
        if (startIdx < 1) {startIdx = 1}
        endIdx = startIdx + (maxFiles - 1)
        if (endIdx > numVideos) {endIdx = numVideos}

        ## Determine current page number
        if (startIdx == 1) {
            currPage = 1
        } else {
            currPage = (startIdx + (maxFiles - 1)) / maxFiles
        }
        
        ## Display the current page of results
        displayFiles(d[startIdx:endIdx,])
        ## For the current page, maxItem is the maximum allowable item
        ## number response
        maxItem = dim(d[startIdx:endIdx,])[1]
        ## If the final page of results has less entries than
        ## maxFiles, then we pad with extra blank lines so that the
        ## user doesn't experience the input prompt moving around
        cat(paste(rep("\n", (maxFiles - maxItem)), collapse=""))

        ## Get user input with custom prompt
        cat(sprintf("\nItem # to play\t\t\t\t\t\t Page %d/%d\n",
                    currPage, maxPage))
        if (endIdx < numVideos & startIdx > 1) {
            cat("[n]ext or [p]revious page\n")
        } else if (endIdx < numVideos) {
            cat("[n]ext page\n")
        } else if (startIdx > 1) {
            cat("[p]revious page\n")
        } 
        cat(">> ")
        
        resp = readLines(file("stdin"), 1)
        newStartIdx = handleResp(d, resp, startIdx, maxFiles, maxItem) 

        ## If handleResp returned zero, the user has asked to quit.
        if (newStartIdx == 0) {
            browsep = FALSE
        }

        ## Reset the index for the current page of results
        if (newStartIdx < numVideos) {
            startIdx = newStartIdx
        }
            
    }
    ## We're done

} 

## Auto-run below here

## Find videos files recursively within root directory
d = getFileData(root)
## Start the file browser
fileBrowser(d)
## We're done... clear the terminal and exit
system("clear")

## End of file m
